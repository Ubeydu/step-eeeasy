package com.example.stepeeeasy.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.stepeeeasy.data.local.entity.WalkEntity
import kotlinx.coroutines.flow.Flow

/**
 * Data Access Object (DAO) for Walk entities.
 *
 * Room will automatically generate implementations for these methods.
 * All methods are suspend functions (for coroutines) or return Flow (for reactive updates).
 */
@Dao
interface WalkDao {

    // ========================================
    // CREATE operations
    // ========================================

    /**
     * Insert a new walk into the database.
     *
     * @param walk The walk to insert
     * @return The ID of the newly inserted walk (auto-generated by Room)
     *
     * Explanation:
     * - @Insert tells Room to generate an INSERT SQL statement
     * - suspend keyword makes this a coroutine function (non-blocking)
     * - Returns Long which is the auto-generated ID from the database
     */
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertWalk(walk: WalkEntity): Long

    // ========================================
    // READ operations
    // ========================================

    /**
     * Get the currently active walk (if any).
     *
     * Returns Flow so the UI can automatically update when the active walk changes.
     *
     * Explanation:
     * - @Query lets you write custom SQL queries
     * - Flow<WalkEntity?> means this will emit updates whenever the data changes
     * - WHERE is_active = 1 filters to only active walks (true in SQL is 1)
     * - LIMIT 1 ensures we only get one result (there should only be one active walk)
     * - Returns null if no active walk exists
     */
    @Query("SELECT * FROM walks WHERE is_active = 1 LIMIT 1")
    fun getActiveWalk(): Flow<WalkEntity?>

    /**
     * Get the currently active walk (synchronous version).
     *
     * This is a SUSPEND function (not Flow) that returns the current value immediately.
     * Used when you need to get the active walk once (e.g., to stop it).
     *
     * Difference from getActiveWalk():
     * - getActiveWalk() returns Flow (observes changes over time)
     * - getActiveWalkNow() returns WalkEntity? (one-time fetch)
     */
    @Query("SELECT * FROM walks WHERE is_active = 1 LIMIT 1")
    suspend fun getActiveWalkNow(): WalkEntity?

    /**
     * Get all walks, ordered by start time (most recent first).
     *
     * Explanation:
     * - ORDER BY start_time DESC sorts newest walks first
     * - Flow<List<WalkEntity>> emits updates when any walk changes
     */
    @Query("SELECT * FROM walks ORDER BY start_time DESC")
    fun getAllWalks(): Flow<List<WalkEntity>>

    /**
     * Get walks within a specific date range.
     *
     * @param startDate Format: "YYYY-MM-DD" (e.g., "2025-10-13")
     * @param endDate Format: "YYYY-MM-DD" (e.g., "2025-10-19")
     * @return Flow of walks in that date range
     *
     * Explanation:
     * - :startDate and :endDate are parameters that get replaced with the function arguments
     * - BETWEEN is SQL syntax for inclusive range (>= startDate AND <= endDate)
     */
    @Query("SELECT * FROM walks WHERE date BETWEEN :startDate AND :endDate ORDER BY start_time DESC")
    fun getWalksByDateRange(startDate: String, endDate: String): Flow<List<WalkEntity>>

    /**
     * Get a single walk by its ID.
     *
     * Explanation:
     * - Used when you need to fetch a specific walk (e.g., to show details)
     * - Returns null if walk with that ID doesn't exist
     */
    @Query("SELECT * FROM walks WHERE id = :walkId")
    suspend fun getWalkById(walkId: Long): WalkEntity?

    // ========================================
    // UPDATE operations
    // ========================================

    /**
     * Update an existing walk.
     *
     * Used when stopping a walk (to update endTime, totalSteps, distanceMeters, isActive).
     *
     * Explanation:
     * - @Update generates an UPDATE SQL statement
     * - Room matches the walk by its ID (primary key)
     * - All other fields in the object will be updated
     */
    @Update
    suspend fun updateWalk(walk: WalkEntity)

    // ========================================
    // DELETE operations
    // ========================================

    /**
     * Delete all walks from the database.
     *
     * Used for the "Clear Recorded Walks" feature in Settings.
     *
     * Explanation:
     * - DELETE FROM walks removes all rows from the walks table
     * - GPS points will be automatically deleted due to CASCADE in GpsPointEntity
     */
    @Query("DELETE FROM walks")
    suspend fun deleteAllWalks()

    /**
     * Delete a specific walk by ID.
     *
     * Explanation:
     * - WHERE id = :walkId filters to only delete the specified walk
     * - Associated GPS points will be deleted automatically (CASCADE)
     */
    @Query("DELETE FROM walks WHERE id = :walkId")
    suspend fun deleteWalkById(walkId: Long)
}